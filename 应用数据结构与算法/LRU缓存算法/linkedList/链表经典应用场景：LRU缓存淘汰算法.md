# 链表经典应用场景：LRU缓存淘汰算法

> 或许很多人并不知道学习算法与数据结构到底有什么用，只是人云亦云。
>
> 哦算法与数据结构很重要，学就完事！
>
> 但是任何脱离实际应用的学习，都不能掌握其精髓！
>
> 所以我们需要通过具体的应用场景去分析使用哪个算法，使用哪个数据结构能够达到最好的效果。
>
> 在某些场景下需要用时间复杂度去置换空间复杂度，比如在一些小型硬件上，没有太多的存储资源，采用这种方式比较好。
>
> 而在某些性能要求高的场景下，则需要用空间复杂度去置换时间复杂度了。
>
> 所以呢我将创建一个系列，专门从实际应用的角度去讲解如何使用算法与数据结构。

第一篇就来说说链表。

首先问一个问题？学习链表有什么用呢？那就请带着这个问题阅读吧！

## 缓存

缓存是一种提高数据读取性能的技术，在硬件设计，软件开发中都有非常广泛的作用，比如常见的CPU缓存，数据库缓存，浏览器缓存等等。

缓存大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。

常见的策略有三种：

* 先进先出策略（FIFO，First In，First Out）
* 最少使用策略（LFU，Least Rrequently Used）
* 最近最少使用策略（LRU，Least Recently Used）

打个很形象的比喻。你买了很多的技术书，但有一天你发现，书很多，你要决定哪一本书要拿来垫显示屏。你会选择哪些书拿来垫显示屏呢？

像这样！

<img src="http://picture.nj-jay.com/image-20210422204126526.png" alt="image-20210422204126526" style="zoom: 33%;" />

## 数组与链表

![img](http://picture.nj-jay.com/d5d5bee4be28326ba3c28373808a62cd.jpg)

从底层的存储结构看，数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个100MB大小的数组，当内存中没有连续的，足够大的存储空间，即便内存的剩余可用空间大于100MB，仍然会申请失败！

而链表不一样，它并不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来使用，所以我们如果申请的是100MB大小的链表，是不会出现问题的！

链表又分为：

* 单链表
* 循环链表
* 双向链表
* 双向循环链表

![img](http://picture.nj-jay.com/4f63e92598ec2551069a0eef69db7168.jpg)

对于数组而言，随机访问的时间复杂度是O(1)，插入删除的时间复杂度是O(n)。

而对于链表来说，不支持随机访问，只能遍历链表，所以时间复杂度是O(n)，但是插入删除的效率较高，为O(1)。

但是数组和链表的对比，并不能局限于时间复杂度。而且在实际的软件开发中，不能仅利用复杂度分析就决定使用哪个数据结构来存储数据。

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问起来效率更高。

而链表在内存中并不是连续存储的，所以对CPU缓存不友好，没办法有效预读！

但是数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配，将会导致 "out of memory"。

如果声明的过小，又会导致不够用的情况，所以数组的使用，一般当事先要能确定需要多大的空间。

链表则天然的支持动态扩容，这是与数组最大的区别。

## 用链表实现LRU缓存淘汰算法

**由于需要多次删除插入数据，所以会使用链表这个数据结构。**

思路：

维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始遍历链表：

* 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后插入到链表的头部。
* 如果此数据没有在缓存链表中，将分为两种情况：
  * 如果缓存未满，则将此结点直接插入到链表的头部。
  * 如果缓存已满，需要先将链表的尾结点删除，再讲新的数据结点插入到链表的头部。

这样我们就用链表实现了一个最简单的LRU缓存。当然这种方式还是有缺陷。因为不管缓存有没有满，我们都需要遍历一遍链表，缓存访问的时间复杂度是O(n)。我们可以继续优化这个实现思路，比如加上哈希表来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。

